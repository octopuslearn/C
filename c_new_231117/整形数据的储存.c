#define _CRT_SECURE_NO_WARNINGS
//!!!注意：有符号的整型提升看符号位，负数即1补1，正数即0补0
//!!!注意：无符号的整型提升补0
//出现%u则，原反补相同

//从不同视角来看
//%u认为内存中是无符号
//%d认为内存中是有符号
//unsigned int a = -10认为内存中是无符号的

int main()
{
	/*
	* 总的来说：
	* 1.有符号的，无符号的正数%d %u都是原数
	* 2.无符号的负数	%d -原数 %u很大
	* 3.有符号的负数	%d 原数  %u很大
	*/
	unsigned int a = 10;	//0a 00 00 00	//10
	unsigned int b = -10;	//f6 ff ff ff	//4294967286
	int c = 10;				//0a 00 00 00	//10
	int d = -10;			//f6 ff ff ff	//-10
	printf("unsigned int a = 10--->%d\n", a);	//10
	printf("unsigned int a = 10--->%u\n", a);	//10
	printf("unsigned int b = -10--->%d\n", b);	//-10
	printf("unsigned int b = -10--->%u\n", b);	//4294967286
	printf("signed int c = 10--->%d\n", c);	//10
	printf("signed int c = 10--->%u\n", c);	//10
	printf("signed int d = -10--->%d\n", d);	//-10
	printf("signed int d = -10--->%u\n", d);	//4294967286
	return 0;
}




//尚未解决的问题：int四个字节是咋存的？0x00BDF93C  01 00 00 00  ....
//				2.int指针指向的是int型的哪一个字节


#include <stdio.h>

/*************** int型 在内存中的存储，大小端****************/
//int main()
//{
//	/*局部变量存储在栈区，先定义的放在高地址，后定义的放在低地址。先试用高地址空间，后使用低地址空间*/
//	/*小端存储模式（内存低地址存低位，01在最左边）*/
//	/*内存中存的是补码
//	1.正数1 符号位0
//		原码 00000000000000000000000000000001
//		反码 00000000000000000000000000000001
//		补码 00000000000000000000000000000001
//
//		正数原码，反码，补码相同
//	2.负数-1 符号位1
//		原码 10000000000000000000000000000001
//		反码 11111111111111111111111111111110
//		补码 11111111111111111111111111111111
//
//		反码：原码符号位不变，其他位取反
//		补码：反码+1
//	*/
//
//	/*int 默认singned(有符号)*/
//	//地址0x0093FD94	里面的内容01 00 00 00
//	int a = 1;	
//	//地址0x0093FD88 里面的内容 ff ff ff ff
//	int b = -1;
//
//	//%d-格式化输出有符号的
//	printf("%d\n", a);	//1
//	printf("%d\n", b);	//-1
//
//	
//	printf("无符号%u\n", a);	//1
//	/*%u打印无符号，无符号会将符号位看做普通的二进制位*/
//	//-1补码 11111111111111111111111111111111
//	//  反码 11111111111111111111111111111110
//	//  原码 10000000000000000000000000000001
//	// 2^31+1
//	printf("无符号%u\n", b);	//4294967295
//	return 0;
//}



/*************** char型 ****************/
//int main()
//{
//	/*cpu内整型运算器操作长度为int,不足int的char short int要整形提升
//	有符号的整型提升，整型提升依据是符号位
//  无符号的整型提升补0
//	1.正数整型提升，补0
//	2.负号整型提升，补1
//	*/
//	//例如char c = 1
//	//			原码 00000000000000000000000000000001
//	//			反码 00000000000000000000000000000001
//	//			补码 00000000000000000000000000000001
//	//	截断 c中存储0000 0001
//	//char d = -1
//	//	原码 00000000000000000000000000000001
//	//	反码 11111111111111111111111111111110
//	//	补码 11111111111111111111111111111111
//	//截断 d中储存1111 1111
//
//	//有符号%d --- 整型提升
//	// 0000 0001
//	//1---补码000000000000000000000000 0000 0001
//	//	  原码000000000000000000000000 0000 0001
//	//printf("有符号%d", 1);---1
//
//
//
//	//1111 1111
//	//负数-1补码111111111111111111111111 1111 1111
//	//	    反码111111111111111111111111 1111 1110
//	//		原码100000000000000000000000 0000 0001
//	//printf("有符号%d", d);--- -1
//	char c = 1;
//	char d = -1;
//
//	printf("有符号%d", c);	//1
//	printf("有符号%d", d);	//-1
//
//
//	printf("无符号%u", c);	//1
//	printf("无符号%u", d);	//2^31+1
//	//理由是%u打印，原反补相同
//
//	return 0;
//}


/*判断编译器是大端字节序，还是小端字节序*/

//int main()
//{	
//	//查看是大还是小，只需判断1在左还是在右
//	//int是四个字节，只需要一个字节，故而用char* 指针的类型决定的是一次操作几个字符
//
//	int a = 1;	//0x009BFB28  01 00 00 00
//	/*char* a_is = (char*)&a;*/
//	char* a_is = &a;	//不强转好像也没什么影响
//	if (*a_is == 1)
//		printf("小端\n");	//小端
//	else if (*a_is == 0)
//		printf("大端\n");
//
//	return 0;
//}

//百度面试题的写法
//int a_chakan()
//{
//	int a = 1;
//	return *((char*)&a);
//}
//
//
//int main()
//{
//	int a_is = a_chakan();
//	if (a_is == 1)
//		printf("小端\n");
//	else
//		printf("大端\n");
//	return 0;
//}





/*到底输出什么*/
/**** 1. ****/

//int main()
//{
//	char a = -1;	//###错的:2^31+1
//	//原码100000000 000000000 000000000 000000001
//	 // 反码111111111 111111111 111111111 111111110
//	 // 补码111111111 111111111 111111111 111111111
//	 // 截断111111111
//  //整型提升111111111 111111111 111111111 111111111
//	 // 反码111111111 111111111 111111111 111111110
//	 // 原码100000000 000000000 000000000 000000001
//  //--- -1
//
//	signed char b = -1;	//###错的:2^31+1
//	  //原码100000000 000000000 000000000 000000001
//	  //反码111111111 111111111 111111111 111111110
//		 // 补码111111111 111111111 111111111 111111111
//		 // 截断111111111
//		 // 整型提升111111111 111111111 111111111 111111111
//		 // 反码111111111 111111111 111111111 111111110
//		 // 原码100000000 000000000 000000000 000000001
//		 // -- - -1
//	unsigned char c = -1;	//错的:1
// //   原码100000000 000000000 000000000 000000001
// //   反码111111111 111111111 111111111 111111110
// //   补码111111111 111111111 111111111 111111111
// //   截断111111111
////###错的：整型提升111111111 111111111 111111111 111111111
////unsigned char是无符号的，所有说补0
////!!!对的：整型提升000000000 000000000 000000000 111111111 --- 255 
//					 此时是正数---原码反码补码相同
////!!!无符号的整型提升补0
//	printf("a=%d,b=%d,c=%d", a, b, c);	//a=-1,b=-1,c=255	////为啥c=255???--- 无符号的整型提升补0
//	return 0;
//}


//int main()
//{
//	char a = -128;
//	//100000000 000000000 000000000 010000000
// //   111111111 111111111 111111111 101111111
//	//111111111 111111111 111111111 100000000
//
//	//100000000
//	//111111111 111111111 111111111 100000000---错的：128???
//
//	printf("%u\n", a);	//4294967168
//	//理由是%u无符号形式打印，无符号原反补相同
//	return 0;
//}


//int main()
//{
//	char a = 128;
//	/*10000000 00000000 00000000 10000000
//	整数原反补相同
//	10000000
//	11111111 11111111 11111111 10000000
//	%u原反补形同---*/
//	printf("%u\n", a);	//4,294,967,168
//	return 0;
//}

//int main()
//{
//	int a = -20;
//  /*10000000 00000000 00000000 00010100
//	11111111 11111111 11111111 11101011
//	11111111 11111111 11111111 11101100*/
//	//--- -20
//	printf("%d\n", a);	//-20
//	return 0;
//}


//int main()
//{
//	int a = -20;
////  /*10000000 00000000 00000000 00010100
////	11111111 11111111 11111111   11101011
////	11111111 11111111 11111111   11101100*/
//
///*	正数原反补相同
//	00000000 00000000 00000000 00001010
//	11111111 11111111 11111111 11101100
//补码11111111 11111111 11111111 11110110
//因为要打印%d
//	11111111 11111111 11111111 11110101
//	10000000 00000000 00000000 00001010
//    --- -10*/
////	实际上unsigned+signed都是补码的相加，尽管算数转换signed会转换成unsigned然后再进行运算
//	unsigned int j = 10;
//	printf("%d\n", a+j);	//
//	return 0;
//}