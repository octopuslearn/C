#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
//!!!!!!!注意：无论有无符号，内存中都是补码，有没有符号位都是看数，而不是看数据类型
//!!!注意：有符号的整型提升看符号位，负数即1补1，正数即0补0
//!!!注意：无符号的整型提升补0
//出现%u则，原反补相同

//从不同视角来看
//%u认为内存中是无符号
//%d认为内存中是有符号
//unsigned int a = -10认为内存中是无符号的

//int main()
//{
//	/*
//	* 总的来说：
//	* 1.有符号的，无符号的正数%d %u都是原数
//	* 2.无符号的负数	%d 负数	 %u很大
//	* 3.有符号的负数	%d 负数  %u很大
//	*/
//	unsigned int a = 10;	//0a 00 00 00	//10
//	unsigned int b = -10;	//f6 ff ff ff	//4294967286
//
// //   10000000 00000000 00000000 00001010
// //   11111111 11111111 11111111 11110101
// //   11111111 11111111 11111111 11110110
//	int c = 10;				//0a 00 00 00	//10
//	int d = -10;			//f6 ff ff ff	//-10
//	printf("unsigned int a = 10--->%d\n", a);	//10
//	printf("unsigned int a = 10--->%u\n", a);	//10
//	printf("unsigned int b = -10--->%d\n", b);	//-10
//	printf("unsigned int b = -10--->%u\n", b);	//4294967286
//	printf("signed int c = 10--->%d\n", c);	//10
//	printf("signed int c = 10--->%u\n", c);	//10
//	printf("signed int d = -10--->%d\n", d);	//-10
//	printf("signed int d = -10--->%u\n", d);	//4294967286
//	return 0;
//}




//尚未解决的问题：int四个字节是咋存的？0x00BDF93C  01 00 00 00  ....
//				2.int指针指向的是int型的哪一个字节


#include <stdio.h>

/*************** int型 在内存中的存储，大小端****************/
//int main()
//{
//	/*局部变量存储在栈区，先定义的放在高地址，后定义的放在低地址。先试用高地址空间，后使用低地址空间*/
//	/*小端存储模式（内存低地址存低位，01在最左边）*/
//	/*内存中存的是补码
//	1.正数1 符号位0
//		原码 00000000000000000000000000000001
//		反码 00000000000000000000000000000001
//		补码 00000000000000000000000000000001
//
//		正数原码，反码，补码相同
//	2.负数-1 符号位1
//		原码 10000000000000000000000000000001
//		反码 11111111111111111111111111111110
//		补码 11111111111111111111111111111111
//
//		反码：原码符号位不变，其他位取反
//		补码：反码+1
//	*/
//
//	/*int 默认singned(有符号)*/
//	//地址0x0093FD94	里面的内容01 00 00 00
//	int a = 1;	
//	//地址0x0093FD88 里面的内容 ff ff ff ff
//	int b = -1;
//
//	//%d-格式化输出有符号的
//	printf("%d\n", a);	//1
//	printf("%d\n", b);	//-1
//
//	
//	printf("无符号%u\n", a);	//1
//	/*%u打印无符号，无符号会将符号位看做普通的二进制位*/
//	//-1补码 11111111111111111111111111111111
//	//  反码 11111111111111111111111111111110
//	//  原码 10000000000000000000000000000001
//	// 2^31+1
//	printf("无符号%u\n", b);	//4294967295
//	return 0;
//}



/*************** char型 ****************/
//int main()
//{
//	/*cpu内整型运算器操作长度为int,不足int的char short int要整形提升
//	有符号的整型提升，整型提升依据是符号位
//  无符号的整型提升补0
//	1.正数整型提升，补0
//	2.负号整型提升，补1
//	*/
//	//例如char c = 1
//	//			原码 00000000000000000000000000000001
//	//			反码 00000000000000000000000000000001
//	//			补码 00000000000000000000000000000001
//	//	截断 c中存储0000 0001
//	//char d = -1
//	//	原码 00000000000000000000000000000001
//	//	反码 11111111111111111111111111111110
//	//	补码 11111111111111111111111111111111
//	//截断 d中储存1111 1111
//
//	//有符号%d --- 整型提升
//	// 0000 0001
//	//1---补码000000000000000000000000 0000 0001
//	//	  原码000000000000000000000000 0000 0001
//	//printf("有符号%d", 1);---1
//
//
//
//	//1111 1111
//	//负数-1补码111111111111111111111111 1111 1111
//	//	    反码111111111111111111111111 1111 1110
//	//		原码100000000000000000000000 0000 0001
//	//printf("有符号%d", d);--- -1
//	char c = 1;
//	char d = -1;
//
//	printf("有符号%d", c);	//1
//	printf("有符号%d", d);	//-1
//
//
//	printf("无符号%u", c);	//1
//	printf("无符号%u", d);	//2^31+1
//	//理由是%u打印，原反补相同
//
//	return 0;
//}


/*判断编译器是大端字节序，还是小端字节序*/

//int main()
//{	
//	//查看是大还是小，只需判断1在左还是在右
//	//int是四个字节，只需要一个字节，故而用char* 指针的类型决定的是一次操作几个字符
//
//	int a = 1;	//0x009BFB28  01 00 00 00
//	/*char* a_is = (char*)&a;*/
//	char* a_is = &a;	//不强转好像也没什么影响
//	if (*a_is == 1)
//		printf("小端\n");	//小端
//	else if (*a_is == 0)
//		printf("大端\n");
//
//	return 0;
//}

//百度面试题的写法
//int a_chakan()
//{
//	int a = 1;
//	return *((char*)&a);
//}
//
//
//int main()
//{
//	int a_is = a_chakan();
//	if (a_is == 1)
//		printf("小端\n");
//	else
//		printf("大端\n");
//	return 0;
//}





/*到底输出什么*/
/**** 1. ****/

//int main()
//{
//	char a = -1;	//###错的:2^31+1
//	//原码100000000 000000000 000000000 000000001
//	 // 反码111111111 111111111 111111111 111111110
//	 // 补码111111111 111111111 111111111 111111111
//	 // 截断111111111
//  //整型提升111111111 111111111 111111111 111111111
//	 // 反码111111111 111111111 111111111 111111110
//	 // 原码100000000 000000000 000000000 000000001
//  //--- -1
//
//	signed char b = -1;	//###错的:2^31+1
//	  //原码100000000 000000000 000000000 000000001
//	  //反码111111111 111111111 111111111 111111110
//		 // 补码111111111 111111111 111111111 111111111
//		 // 截断111111111
//		 // 整型提升111111111 111111111 111111111 111111111
//		 // 反码111111111 111111111 111111111 111111110
//		 // 原码100000000 000000000 000000000 000000001
//		 // -- - -1
//	unsigned char c = -1;	//错的:1
// //   原码100000000 000000000 000000000 000000001
// //   反码111111111 111111111 111111111 111111110
// //   补码111111111 111111111 111111111 111111111
// //   截断111111111
////###错的：整型提升111111111 111111111 111111111 111111111
////unsigned char是无符号的，所有说补0
////!!!对的：整型提升000000000 000000000 000000000 111111111 --- 255 
//					 此时是正数---原码反码补码相同
////!!!无符号的整型提升补0
//	printf("a=%d,b=%d,c=%d", a, b, c);	//a=-1,b=-1,c=255	////为啥c=255???--- 无符号的整型提升补0
//	return 0;
//}


//int main()
//{
//	char a = -128;
//	//100000000 000000000 000000000 010000000
// //   111111111 111111111 111111111 101111111
//	//111111111 111111111 111111111 100000000
//
//	//100000000
//	//111111111 111111111 111111111 100000000---错的：128???
//
//	printf("%u\n", a);	//4294967168
//	//理由是%u无符号形式打印，无符号原反补相同
//	return 0;
//}


//int main()
//{
//	char a = 128;
//	/*10000000 00000000 00000000 10000000
//	整数原反补相同
//	10000000
//	11111111 11111111 11111111 10000000
//	%u原反补形同---*/
//	printf("%u\n", a);	//4,294,967,168
//	return 0;
//}

//int main()
//{
//	int a = -20;
//  /*10000000 00000000 00000000 00010100
//	11111111 11111111 11111111 11101011
//	11111111 11111111 11111111 11101100*/
//	//--- -20
//	printf("%d\n", a);	//-20
//	return 0;
//}

/*例4*/
//有符号+无符号
//int main()
//{
//	int a = -20;
////  /*10000000 00000000 00000000 00010100
////	11111111 11111111 11111111   11101011
////	11111111 11111111 11111111   11101100*/
//
///*	正数原反补相同
//	00000000 00000000 00000000 00001010
//	11111111 11111111 11111111 11101100
//补码11111111 11111111 11111111 11110110
//因为要打印%d
//	11111111 11111111 11111111 11110101
//	10000000 00000000 00000000 00001010
//    --- -10*/
////	实际上unsigned+signed都是补码的相加，尽管算数转换signed会转换成unsigned然后再进行运算
//	unsigned int j = 10;
//	printf("%d\n", a+j);	//
//	return 0;
//}




/*例5*/
//结果死循环，理由unsigned int永远>=0
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//		printf("%u\n", i);
//	//4294833809	可是为什么结果是这个而不是9-0？？？理由：经过调试，的确是从9-0然后才从4294967295开始
//	//	4294833808
//	//	4294833807
//	//	4294833806
//	//	4294833805
//	//	4294833804
//	//	4294833803
//	//	4294833802
//	//	4294833801
//	//	4294833800
//	//	4294833799
// 
// 
// 9
//8调试结果
//7
//6
//5
//4
//3
//2
//1
//0
//4294967295

//	return 0;
//}

/*例6*/
//int main()
//{
//	char a[1000];
//	int i;
//	printf("%d\n", strlen(a));	//1011这里每次都不一样？？？理由是strlen遇到0即\0就结束
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//		//调试得：内存中存的是-1--- -128 --- 127---0
//		//-1 10000000 00000000 00000000 00000001 ---1
//		//   11111111 11111111 11111111 11111110
//		//   11111111 11111111 11111111 11111111
//		//	 11111111--- -127
//
//		//-2 10000000 00000000 00000000 00000010 ---2
//		//   11111111 11111111 11111111 11111101
//		//	 11111111 11111111 11111111 11111110
//		//	 11111110--- -126
//	}
//	
//	printf("%d", strlen(a));	//255 理由：strlen遇到0即\0停止
//	return 0;
//}

/*例7*/
//死循环
unsigned char i = 0;
int main()
{
	for (i = 0; i <= 255; i++)
	{
		printf("hello world\n");
		printf("%d", i);
	}
		
	return 0;
}